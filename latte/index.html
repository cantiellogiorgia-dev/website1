<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <title>Composizione Dinamica - Minimal Ripple</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <style>
        body { margin: 0; padding: 0; background: #000; overflow: hidden; }
        canvas { display: block; }
    </style>
</head>
<body>

<script>
let elements = [];
let timer = 0;
let step = 0; 
let wordLatte = "LATTE";
let wordElla = "ELLA";
let wordGinocchia = "GINOCCHIA";
let index = 0;

// Variabili Sfondo e Onde
let gridSize = 12; 
let bgPattern = [];
let ripples = []; 

function setup() {
    createCanvas(windowWidth, windowHeight);
    textFont('Helvetica, Arial, sans-serif');
    textStyle(BOLD);
    textSize(50);
    generateBackground();
}

function generateBackground() {
    bgPattern = [];
    let cols = ceil(width / gridSize);
    let rows = ceil(height / gridSize);
    for (let i = 0; i < cols; i++) {
        bgPattern[i] = [];
        for (let j = 0; j < rows; j++) {
            bgPattern[i][j] = (floor(random(1, 6)) === 1);
        }
    }
}

function mousePressed() {
    // Genera 3 onde molto sottili con velocitÃ  diverse
    ripples.push(new Ripple(mouseX, mouseY, 7, 15));  // Onda veloce e sottile
    ripples.push(new Ripple(mouseX, mouseY, 4, 10));  // Onda media
    ripples.push(new Ripple(mouseX, mouseY, 2.5, 8)); // Onda lenta e finissima
}

function draw() {
    drawRippleBackground();

    // Logica comparsa lettere
    if (millis() - timer > 300) {
        if (step === 0) {
            elements.push(new MovingLetter(wordLatte[index], width * 0.2, height + 50, 0, -3.5));
            index++;
            if (index >= wordLatte.length) { step = 1; index = 0; }
        } else if (step === 1) {
            elements.push(new MovingLetter(wordElla[index], -50, height * 0.5, 5, 0));
            index++;
            if (index >= wordElla.length) { step = 2; index = 0; }
        } else if (step === 2) {
            elements.push(new MovingLetter(wordGinocchia[index], width * 0.8, -50, 0, 3.5));
            index++;
            if (index >= wordGinocchia.length) { step = 0; index = 0; }
        }
        timer = millis();
    }

    // Aggiornamento lettere
    for (let i = elements.length - 1; i >= 0; i--) {
        elements[i].update();
        elements[i].display();
        if (elements[i].isOffScreen()) elements.splice(i, 1);
    }

    // Gestione onde
    for (let i = ripples.length - 1; i >= 0; i--) {
        ripples[i].update();
        if (ripples[i].isFinished()) ripples.splice(i, 1);
    }
}

function drawRippleBackground() {
    noStroke();
    let cols = bgPattern.length;
    let rows = bgPattern[0].length;

    for (let i = 0; i < cols; i++) {
        for (let j = 0; j < rows; j++) {
            let px = i * gridSize;
            let py = j * gridSize;
            let isColored = bgPattern[i][j];

            for (let r of ripples) {
                let d = dist(px, py, r.x, r.y);
                // L'inversione avviene solo in una fascia molto stretta (linea sottile)
                if (d < r.radius && d > r.radius - r.thickness) {
                    isColored = !isColored;
                }
            }

            fill(isColored ? 65 : 0); // Solo nero e grigio, senza bordi
            rect(px, py, gridSize, gridSize);
        }
    }
}

class Ripple {
    constructor(x, y, speed, thickness) {
        this.x = x;
        this.y = y;
        this.radius = 0;
        this.speed = speed;
        this.thickness = thickness;
        this.maxRadius = max(width, height) * 1.5;
    }
    update() {
        this.radius += this.speed;
    }
    isFinished() {
        return this.radius > this.maxRadius + this.thickness;
    }
}

class MovingLetter {
    constructor(char, x, y, speedX, speedY) {
        this.char = char;
        this.x = x;
        this.y = y;
        this.speedX = speedX;
        this.speedY = speedY;
    }
    update() {
        this.x += this.speedX;
        this.y += this.speedY;
    }
    display() {
        noStroke(); // Rimuove eventuali bordi dalle lettere
        fill(255);
        textAlign(CENTER, CENTER);
        text(this.char, this.x, this.y);
    }
    isOffScreen() {
        return (this.x < -150 || this.x > width + 150 || this.y < -150 || this.y > height + 150);
    }
}

function windowResized() {
    resizeCanvas(windowWidth, windowHeight);
    generateBackground();
}
</script>

</body>
</html>